## 자료형
참고로 코딩 테스트에서 가장 많이 사용하는 자료형은 리스트 (`list`)와 딕셔너리 (`dict`)이다.

### 파이썬 자료형
파이썬에서 지원하는 주요 자료형은 다음과 같다.
- None (class None Type)
- 숫자
- 매핑
- 집합
- 시퀀스

#### 숫자
파이썬에서 **숫자 정수형으로 `int`만을 제공한다.** 원래 파이썬 버전 2까지는 고정 정밀도 정수형인 `int`와 임의 정밀도 정수형인 `long`을 각각 별도로 제공했다. 그러다 버전 2.4부터 `int`가 충분하지 않으면 자동으로 `long` 타입으로 변경되는 구조가 되었고, 버전 3부터는 아예 `int` 단일형으로 통합되었다.<br>**`bool`은 논리 자료형이지만 파이썬 내부에서는 1 (`True`)와 0 (`False`)으로 처리되는 `int`의 서브 클래스**이다. 다음과 같은 구조를 띤다.
```commandline
object > int > bool
```
> #### 임의 정밀도
> 임의 정밀도 정수형이란 무제한 자릿수를 제공하는 정수형을 말한다. 숫자를 임의 정밀도로 처리하면 계산 속도가 저하되지만, 언어를 매우 단순한 구조로 만들 수 있고 오버플로를 고민할 필요가 없다.

#### 매핑
매핑은 키 (Key)와 자료형 (Value)으로 구성된 복합 자료형이다. 파이썬에 내장된 유일한 **매핑 자료형은 딕셔너리 (`dict`)이다.**

#### 집합
**집합 자료형인 `set`은 다음과 같은 형태로 선언한다.**
```commandline
>>> a = set()
>>> type(a)
>>> <class 'set'>
```
빈 집합이 아닌 경우는 딕셔너리와 동일하게 **중괄호 ({})를 사용**한다. 딕셔너리는 키/값 형태이기 때문에 구분에 있어서 어려움은 없을 것이다.<br>**`set`은 입력 순서가 유지되지 않으며, 중복된 값이 있을 경우 하나의 값만 유지**한다.
```commandline
>>> a = {3, 2, 3, 5}
>>> a
{2, 3, 5}
```

#### 시퀀스
시퀀스는 **어떤 특정 대상의 순서 있는 나열**을 뜻한다.<br>`str`은 문자의 순서 있는 나열로 문자열을 이루는 자료형이다.<br>`list`는 다양한 값들을 배열 형태의 순서 있는 나열로 구성하는 자료형이다. 사실상 배열의 역할을 한다.<br>또한 `str`, `tuple`, `bytes`는 불변 (Immutable)이며 `list`는 가변 (Mutable)이다.

### 원시 타입
> #### 원시 타입 (Primitive Type)
> 원시 타입이란 정수, 실수, 문자, 논리 리터럴 등의 실제 데이터 값을 저장하는 타입이다.

C나 자바가 원시 타입을 기본적으로 제공한다. 동일한 정수형이라도 크기나 부호에 따라 매우 다양한 원시 타입 (`short`, `unsigned short`, `long`, `unsigned long`, `long long` 등)을 제공한다. 원시 타입은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워넣는다. 따라서 매우 빠른 연산이 가능하다.
```commandline
// C or 자바
int a = 5;
```
자바는 원시 타입에 대응되는 클래스 객체 (Object)도 지원한다.
```commandline
// 자바
Integer a = new Integer(5);
```
원시 타입을 객체로 변환하면 문자로 변환하거나 16진수로 변환하거나 비트 조작을 지원한다. 다만, 이를 위해서는 여러 부가 정보가 추가되기 때문에, 메모리 점유율이 늘어나며 계산 속도가 감소한다.<br>자바의 `int` 타입은 32비트이지만 JOL (Java Object Layout)의 객체 `Integer`는 128비트이다. 또한 `bool` 원시 타입은 1비트이지만 객체 `Boolean`은 128비트이다. 이처럼 객체는 편리하고 다양한 기능을 제공하기 위해 일정 부분 속도와 공간을 희생한다.<br>**파이썬은 편리성을 우선순위에 둔 언어이기 때문에 원시 타입을 지원하지 않는다. 따라서 느린 속도와 더 많은 메모리를 차지하더라도 훨씬 더 다양한 기능을 제공할 수 있는 객체에 초점을 두게 된다.**

| 언어   | 지원 타입 형태 |
|------|----------|
| C    | 원시 타입    |
| 자바   | 원시 타입, 객체 |
| 파이썬  | 객체       |

### 객체
**파이썬은 모든 것이 객체**이다. 이 중 불변 객체와 가변 객체로 구분할 수 있는데, 파이썬의 각 자료형에 대해 불변 여부는 다음과 같다.

|클래스|설명|불변 객체|
|---|---|---|
|`bool`|부울|O|
|`int`|정수|O|
|`float`|실수|O|
|`list`|리스트|X|
|`tuple`|리스트와 튜플의 차이는 불변 여부이며 이외에도 거의 동일하다.<br>튜플은 불변이므로 생성할 때 설정한 값은 변경할 수 없다.|O|
|`str`|문자|O|
|`set`|중복된 값을 갖지 않는 집합 자료형|X|
|`dict`|딕셔너리|X|

**파이썬에서 변수를 할당한다는 작업은 해당 객체에 대해 참조를 한다는 의미**이다.

#### 불변 객체
다음 코드를 보자.
```commandline
>>> 10
>>> a = 10
>>> b = a
>>> id(10), id(a), id(b)
>>> (4308025872, 4308025872, 4308025872)
```
만약 모두가 원시 타입이라면 각각의 값들은 각 메모리의 다른 영역에 위치할 것이다. 하지만 파이썬은 모든 것이 객체이므로, `id()` 함수를 실행한 결과는 모두 동일하다.<br>만약 `10`이 `11`이 된다면 `a` 변수와 `b` 변수 모두 값이 `11`이 된다고 생각할 수 있겠지만, `int`는 불변 객체이기 때문에 그런 일이 발생하지 않는다. 즉, **값을 담고 있는 변수 (`a`, `b`)는 참조일 뿐이고 실제로 값을 갖고 있는 `int` (`10`)은 불변 객체**이다. 이외에도 `str`나 `tuple` 역시 불변 객체이다.

#### 가변 객체
가변 시퀀스 중 하나로 리스트가 있다. 다음 코드를 보자.
```commandline
>>> a = [1, 2, 3, 4, 5]
>>> b = a
>>> b
[1, 2, 3, 4, 5]
>>> id(a), id(b)
(4313081024, 4313081024)
>>> a[2] = 4
>>> a, b
[1, 2, 4, 4, 5], [1, 2, 4, 4, 5]
>>> b
[1, 2, 4, 4, 5]
>>> id(a), id(b)
(4313081024, 4313081024)
```
변수 `a`는 `list`이고 `b`에는 `a`를 할당하여 참조가 되게 하였다. `list`는 가변 객체이기 때문에 `a`의 요소 하나가 변경되었을 때 `b`의 요소 역시 변경되었다.
> **불변 객체와 가변 객체의 차이는 객체의 주소가 변하지 않고 값을 바꿀 수 있는지이다.**

> #### 의문점
> ```commandline
> >>> a = [1, 2, 3, 4, 5]
> >>> b = a
> >>> c = [1, 2, 3, 4, 5]
> >>> id([1, 2, 3, 4, 5]), id(a), id(b), id(c)
> (4303517760, 4303518720, 4303518720, 4303485312)
> ```
> 다음과 같은 경우 `[1, 2, 3, 4, 5]`와 `a`와 `c`의 주소값은 다르다. 왜 다른지에 대해서는 모르겠지만 가변 객체이기 때문에 아예 다른 주소가 할당된 것이 아닌가 싶다.

> #### `is`와 `==`
> `is`는 `id()` 값을 비교하는 함수이고, `==`는 값을 비교하는 연산자이다.
> ```commandline
> >>> a = [1, 2, 3]
> >>> a == a, a == list(a)
> (True, True)
> >>> a is a, a is list(a)
> (True, False)
> ```

#### 속도
**파이썬의 객체 구조는 매우 편리하고 강력한 기능을 제공하지만, 문제는 속도**다. 메모리에서 값을 꺼내 한 번 연산하면 끝인 원시 타입에 비해, 파이썬의 객체는 값을 꺼내는 데만 해도 여러 단계를 거쳐야 한다. 이러한 이유로 파이썬은 C나 자바와 같은 다른 언어보다 느리다. 넘파이의 경우 빠른 속도로 유명한데, 이유는 C로 만든 모듈이며 내부적으로 리스트를 C의 원시 타입으로 처리하기 때문이다.<br>그럼에도 불구하고 파이썬이 원시 타입을 사용하지 않는 이유는 Chapter 5에서 살펴보겠다.