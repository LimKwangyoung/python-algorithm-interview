## 딕셔너리
**파이썬의 딕셔너리는 키/값 구조로 이루어진 딕셔너리**를 말한다. 입력 순서가 유지되며, 내부적으로는 해시 테이블로 구현되어 있다. 각 언어별 해시 테이블을 이용한 키/값 구조의 자료형은 다음과 같다.

| 언어  | 해시 테이블              |
|-----|---------------------|
| 파이썬 | `dict()`            |
| C++ | `std::unordered_map` |
| 자바  | `HashMap`           |

인덱스를 숫자로만 지정할 수 있는 리스트와 달리 **딕셔너리는 문자를 포함해 다양한 타입을 키로 사용**할 수 있다. 특히 **파이썬의 경우 불변 객체를 모두 키로 사용**할 수 있다. 이를 해싱이라 한다.<br>또한 해시 테이블은 입력과 조회 모두 O(1)에 가능하다. 최악의 경우 O(n)이 될 수 있으나 대부분의 경우 훨씬 더 빨리 실행되며, 분할 상환 분석에 따른 시간 복잡도는 O(1)이다.

| 연산            | 시간 복잡도 | 설명                   |
|---------------|--------|----------------------|
| `len(a)`      | O(1)   | 요소의 개수를 리턴한다.        |
| `a[key]`      | O(1)   | 키를 조회하여 값을 리턴한다.     |
| `a[key]=value` | O(1)   | 키/값을 삽입한다.           |
| `key in a`    | O(1)   | 딕셔너리에 키가 존재하는지 확인한다. |

이처럼 **딕셔너리는 대부분의 연산이 O(1)에 처리 가능한 우수한 자료형**이다. 코딩 테스트에서 리스트만큼이나 빈번하게 활용된다.
> 원래 파이썬에서 딕셔너리는 입력 순서가 유지되지 않았다. 그러나 파이썬 3.7부터 내부적으로 인덱스를 이용해 입력 순서를 유지하도록 개선됐다. 하지만 코딩 테스트에서 인터프리터의 버전을 정확히 확인할 수 없기 때문에 **입력 순서가 유지될 것이라고 생각하는 것은 위험**하다.<br>또한 파이썬 3.6부터는 딕셔너리의 메모리 사용량이 20% 정도 줄어드는 성능 개선이 이루어졌다.

### 딕셔너리의 활용 방법
딕셔너리는 다음과 같이 선언할 수 있다.
```commandline
>>> a = dict()
>>> a = {}
```
`key1`, `key2`와 같이 초깃값을 선언할 수 있으며, `key3`처럼 나중에 별도로 선언할 수 있다.
```commandline
>>> a = {'key1':'value1', 'key2':'value2'}
>>> a
{'key1':'value1', 'key2':'value2'}
>>> a['key3'] = 'value3'
>>> a
{'key1':'value1', 'key2':'value2', 'key3':'value3'}
```
딕셔너리의 키를 지정하면 값을 조회할 수 있다.
```commandline
>>> a['key1']
'value1'
```
딕셔너리에서 존재하지 않는 키를 조회하거나 삭제하면 `KeyError` 에러가 발생한다. 이는 `try` 구문으로 예외 처리 할 수 있다. 또한 다음과 같이 키가 존재하는지 미리 확인해 작업하는 방법도 가능하다.
```commandline
>>> 'key4' in a
False
```
딕셔너리에 있는 키/값은 `for` 반복문으로 조회가 가능하다. `items()` 메소드를 사용한다.
```commandline
>>> for k, v in a.items():
...     print(k, v)
...
key1 value1
key2 value2
key3 value3
```
딕셔너리의 키는 `del`로 삭제한다.
```commandline
>>> del a['key1']
>>> a
{'key2': 'value2', 'key3': 'value3'}
```

### 딕셔너리 모듈
`collections` 모듈에서 딕셔너리와 관련된 기능들을 살펴보겠다.

#### defaultdict 객체
`defaultdict` 객체는 존재하지 않는 키를 조회할 경우, **에러 메세지를 출력하는 대신 디폴트 값**을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.
```commandline
>>> a = collections.defaultdict(int)
>>> a['A'] = 5
>>> a['B'] = 4
>>> a
defaultdict(<class 'int'>, {'A': 5, 'B': 4})
```
```commandline
>>> a['C'] += 1
>>> a
defaultdict(<class 'int'>, {'A': 5, 'B': 4, 'C': 1})
```
`C`는 존재하지 않는 키다. 원래였다면 `KeyError`가 발생하겠지만, `defaultdict` 객체는 에러 없이 바로 +1 연산을 가능하게 해준다. 디폴트인 0을 기준으로 자동으로 생성한 후 여기에 1을 더한다.

#### Counter 객체
`Counter` 객체는 **아이템에 대한 개수를 계산해 딕셔너리로 리턴**한다. 다음과 같이 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간다.
```commandline
>>> a = [1, 2, 3, 4, 5, 5, 5, 6, 6]
>>> b = collections.Counter(a)
>>> b
Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})
```
가장 빈도 수가 높은 요소를 추출하고 싶다면 다음과 같이 한다.
```commandline
>>> b.most_common(2)  # 가장 빈도가 높은 2개의 요소를 추출한다.
[(5, 3), (6, 2)]
```

#### OrderedDict 객체
파이썬 3.6 이하의 버전에서는 입력 순서가 유지되지 않았기 때문에, **입력 순서가 유지**되는 `OrderedDict` 객체를 사용하였다.
```commandline
>>> collections.OrderedDict({'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2})
OrderedDict([('banana', 3), ('apple', 4), ('pear', 1), ('orange', 2)])
```
하지만 파이썬 3.7부터 딕셔너리는 내부적으로 인덱스를 이용하여 입력 순서가 유지되도록 개선됐다. 하지만 코딩 테스트 시 하위 버전의 파이썬 인터프리터를 사용하는 경우가 있고, 원래 해시 테이블은 입력 순서에 관여하지 않는 자료형인 만큼, **무턱대고 딕셔너리로 입력 순서를 기대하는 것은 위험**하다.

> #### 타입선언
> ```commandline
> >>> type([])
> <class 'list'>
> >>> type(())
> <class 'tuple'>
> >>> type({})
> <class 'dict'>
> >>> type({0})
> <class 'set'>
> ```